* Setup package straight.el
  Next-generation, purely functional package manager for the Emacs hacker.

  #+BEGIN_SRC emacs-lisp
    (defvar bootstrap-version)
    (let ((bootstrap-file
	   (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
	  (bootstrap-version 5))
      (unless (file-exists-p bootstrap-file)
	(with-current-buffer
	    (url-retrieve-synchronously
	     "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
	     'silent 'inhibit-cookies)
	  (goto-char (point-max))
	  (eval-print-last-sexp)))
      (load bootstrap-file nil 'nomessage))
  #+END_SRC
  
** Install use package
   #+BEGIN_SRC emacs-lisp
     (straight-use-package 'use-package)
   #+END_SRC

* General settings
** No splash screen please ... jeez
   #+BEGIN_SRC emacs-lisp
     (setq inhibit-startup-message t)
   #+END_SRC
** Disable stuff UI
   #+BEGIN_SRC emacs-lisp
     (menu-bar-mode -1)
     (tool-bar-mode -1)
     (tooltip-mode -1)
     (scroll-bar-mode -1)
   #+END_SRC
** Show matching highlight
   #+BEGIN_SRC emacs-lisp
     (electric-pair-mode)
     (show-paren-mode)
   #+END_SRC
** Customize custom file
   #+BEGIN_SRC emacs-lisp
     (setq custom-file (concat user-emacs-directory "custom.el"))
     (load custom-file 'noerror)
   #+END_SRC
** Disable backup
   #+BEGIN_SRC emacs-lisp
     (setq make-backup-files nil)
     (setq auto-save-default nil)
     (setq create-lockfiles nil)
   #+END_SRC
** Delete selected text please, it's basic
#+BEGIN_SRC emacs-lisp
  (delete-selection-mode 1)
#+END_SRC
** Theme
I'll use modus themes because it's builtin to emacs and it's pretty good

#+BEGIN_SRC emacs-lisp
  (defun setup-themes (theme)
    (set-frame-font "Jetbrains Mono 20" nil t)
    (setq default-frame-alist '((font . "Jetbrains Mono 20")))
    (load-theme theme t))

  (setup-themes 'modus-vivendi)
#+END_SRC
** Set email
#+BEGIN_SRC emacs-lisp
  (setq user-mail-address "cherry.ramatis@lamimed.it")
#+END_SRC

* Third party packages
** Completion with vertico/marginalia/consult/orderless/embark
   This is a nicer set of packages to provide completion and actions.

   [[https://github.com/minad/vertico][vertico]]
   [[https://github.com/minad/marginalia][marginalia]]
   [[https://github.com/minad/consult][consult]]
   [[https://github.com/oantolin/orderless][orderless]]
   [[https://github.com/oantolin/embark][embark]]
   
   #+BEGIN_SRC emacs-lisp
     (use-package vertico
       :straight t
       :custom
       (vertico-cycle t)
       :init (vertico-mode))

     (use-package savehist
       :init
       (savehist-mode))

     (use-package orderless
       :straight t
       :custom (completion-styles '(orderless)))

     (use-package marginalia
       :after vertico
       :straight t
       :custom
       (marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil))
       :init
       (marginalia-mode))

     (use-package consult
       :straight t
       :bind (("C-x b" . consult-buffer)
	      ("C-s" . consult-line))
       :hook (completion-list-mode . consult-preview-at-point-mode)
       :init
       (setq register-preview-delay 0
	     register-preview-function #'consult-register-format)
       (advice-add #'register-preview :override #'consult-register-window)
       (advice-add #'completing-read-multiple :override #'consult-completing-read-multiple)
       (setq xref-show-xrefs-function #'consult-xref
	     xref-show-definitions-function #'consult-xref)
       :config
       (consult-customize
	consult-theme
	:preview-key '(:debounce 0.2 any)
	consult-ripgrep consult-git-grep consult-grep
	consult-bookmark consult-recent-file consult-xref
	consult--source-file consult--source-project-file consult--source-bookmark
	:preview-key (kbd "M-."))
       (setq consult-narrow-key "<") ;; (kbd "C-+")
       (setq consult-project-root-function
	     (lambda ()
	       (when-let (project (project-current))
		 (car (project-roots project))))))

     (use-package embark
       :straight t
       :bind (("C-." . embark-act))
       :init
       (setq prefix-help-command #'embark-prefix-help-command)
       :config
       (add-to-list 'display-buffer-alist
		    '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
		      nil
		      (window-parameters (mode-line-format . none)))))

     (use-package embark-consult
       :straight t
       :after (embark consult)
       :demand t
       :hook
       (embark-collect-mode . consult-preview-at-point-mode))
   #+END_SRC
** Modeline
The idea here is install mood-line with minions together.
*** Minions
This package implements a menu that lists enabled minor-modes, as well
as commonly but not currently enabled minor-modes. It can be used to
toggle local and global minor-modes, to access mode-specific menus,
and to get help about modes.

This menu is intended as a replacement for the incomplete yet wide
list of enabled minor-modes that is displayed in the mode line by
default. To use the menu like this, enable Minions mode.
#+BEGIN_SRC emacs-lisp
  (use-package minions
    :straight t
    :config (minions-mode 1))
#+END_SRC
*** Mood line
=mood-line= is a minimal mode-line configuration that aims to
replicate some of the features of the doom-modeline package.
#+BEGIN_SRC emacs-lisp
  (use-package mood-line
    :straight t
    :init (mood-line-mode))
#+END_SRC

** Company inline completion
   Company is a text completion framework for Emacs. The name stands for
   "complete anything". It uses pluggable back-ends and front-ends to retrieve and
   display completion candidates.
   #+BEGIN_SRC emacs-lisp
     (use-package company-mode
       :straight t    
       :hook (after-init . global-company-mode))

     (use-package company-box
       :straight t
       :hook (company-mode . company-box-mode))
   #+END_SRC
** Structural editing for lisp
   ParEdit (paredit.el) is a minor mode for performing structured editing of
   S-expression data. The typical example of this would be Lisp or Scheme source code.

   ParEdit helps **keep parentheses balanced** and adds many keys for moving
   S-expressions and moving around in S-expressions. Its behavior can be jarring for
   those who may want transient periods of unbalanced parentheses, such as when
   typing parentheses directly or commenting out code line by line.

   #+BEGIN_SRC emacs-lisp
     (use-package paredit
       :straight t
       :config
       (add-hook 'emacs-lisp-mode-hook 'paredit-mode))
   #+END_SRC
** Bind general keys
   A simple way to manage personal keybindings with =bind-key= and helper
   functions from =crux=

   #+BEGIN_SRC emacs-lisp
     (defun cherry/delete-word-or-region ()
       (interactive)
       (if (region-active-p)
	   (call-interactively #'kill-region) ;; then
	 (backward-kill-word 1)))

     (defun cherry/smart-kill-buffer ()
       (interactive)
       (if (one-window-p)
	   (kill-current-buffer)
	 (progn
	   (kill-current-buffer)
	   (delete-window))))

     (use-package bind-key
       :straight t
       :config
       (bind-keys
	("M-SPC" . hippie-expand)
	("M-n" . forward-paragraph)
	("M-p" . backward-paragraph)
	("C-w" . cherry/delete-word-or-region)
	("C-x k" . cherry/smart-kill-buffer)
	("s-c" . delete-frame)
	("C-h" . delete-backward-char)))

     (use-package crux
       :after bind-key
       :straight t
       :config
       (bind-keys
	("C-u" . crux-kill-whole-line)
	("C-c k" . crux-kill-other-buffers)
	("C-c d" . crux-duplicate-current-line-or-region)
	("C-c I" . (lambda () (interactive) (find-file "~/.emacs.d/Emacs.org")))
	("C-o" . crux-smart-open-line)
	("C-c t" . nil)
	("C-c tn" . crux-visit-term-buffer)
	("s-j" . crux-top-join-line)))
   #+END_SRC
** Multiple cursors
   Multiple cursors for Emacs. This is some pretty crazy functionality, so yes,
   there are kinks. Don't be afraid though, I've been using it since 2011 with
   great success and much merriment.

   #+BEGIN_SRC emacs-lisp
     (use-package multiple-cursors
       :straight t
       :config
       (global-set-key (kbd "C->") 'mc/mark-next-like-this)
       (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
       (global-set-key (kbd "C-c C-<") 'mc/mark-all-like-this))
   #+END_SRC
** Expand region
   Expand region increases the selected region by semantic units. Just keep pressing
   the key until it selects what you want.

   #+BEGIN_SRC emacs-lisp
     (use-package expand-region
       :straight t
       :config
       (global-set-key (kbd "C-=") 'er/expand-region))
   #+END_SRC
** Which key
   Emacs package that displays available keybindings in popup

   #+BEGIN_SRC emacs-lisp
     (use-package which-key
       :straight t
       :init (which-key-mode))
   #+END_SRC
** Bufler
   Bufler is like a butler for your buffers, presenting them to you in an
   organized way based on your instructions. The instructions are written as grouping
   rules in a simple language, allowing you to customize the way buffers are
   grouped. The default rules are designed to be generally useful, so you don’t have
   to write your own.

   It also provides a workspace mode which allows frames to focus on buffers in
   certain groups. Since the groups are created automatically, the workspaces are
   created dynamically, rather than requiring you to put buffers in workspaces manually.

   #+BEGIN_SRC emacs-lisp
     (use-package bufler
       :after bind-key
       :straight t
       :config (bind-key "C-x C-b" 'bufler))
   #+END_SRC
** Org roam
   Org-roam is a plain-text knowledge management system. It brings some of
   Roam's more powerful features into the Org-mode ecosystem.

   Org-roam borrows principles from the Zettelkasten method, providing a solution for
   non-hierarchical note-taking. It should also work as a plug-and-play
   solution for anyone already using Org-mode for their personal wiki.

   #+BEGIN_SRC emacs-lisp
     (use-package org-roam
       :straight t
       :after org
       :init (setq org-roam-v2-ack t) ;; Acknowledge V2 upgrade
       :custom
       (org-roam-directory (file-truename org-directory))
       :config
       (org-roam-setup)
       :bind (("C-c n f" . org-roam-node-find)
	      ("C-c n g" . org-roam-graph)
	      ("C-c n r" . org-roam-node-random)    
	      ("C-c n c" . org-roam-capture)
	      (:map org-mode-map
		    (("C-c n i" . org-roam-node-insert)
		     ("C-c n o" . org-id-get-create)
		     ("C-c n t" . org-roam-tag-add)
		     ("C-c n a" . org-roam-alias-add)
		     ("C-c n l" . org-roam-buffer-toggle)))))
   #+END_SRC
** Org download
   This extension facilitates moving images from point A to point B.

   Point A (the source) can be:
   
   An image inside your browser that you can drag to Emacs.
   An image on your file system that you can drag to Emacs.
   A local or remote image address in kill-ring. Use the org-download-yank command for
   this. Remember that you can use "0 w" in dired to get an address.
   A screenshot taken using gnome-screenshot, scrot, gm, xclip (on Linux),
   screencapture (on OS X) or , imagemagick/convert (on Windows).
   Use the org-download-screenshot command for this. Customize the backend with
   org-download-screenshot-method.
   
   Point B (the target) is an Emacs org-mode buffer where the inline link
   will be inserted. Several customization options will determine where
   exactly on the file system the file will be stored.

   #+BEGIN_SRC emacs-lisp
     (use-package org-download :straight t)
   #+END_SRC
** Mu4e mailing
   mu4e is an email client for Emacs. It’s based on the mu email indexer/searcher.

   It's not information overload. It's filter failure. mu4e's mission is to
   be a better filter. --Prof. Shirky

   #+BEGIN_SRC emacs-lisp
     (use-package mu4e
       :after bind-key
       :ensure nil
       :load-path "/usr/share/emacs/site-lisp/mu4e/"
       :config
       ;; this is set to 't' to avoid mail syncing issues when using mbsync
       (setq mu4e-change-filenames-when-moving t)

       ;; Refresh mail using isync every 10 minutes
       (setq mu4e-update-interval (* 10 60))
       (setq mu4e-get-mail-command "mbsync -a")
       (setq mu4e-maildir "~/Mail")

       (setq mu4e-drafts-folder "/[Gmail].Drafts")
       (setq mu4e-sent-folder "/[Gmail].Sent Mail")
       (setq mu4e-refile-folder "/[Gmail].All Mail")
       (setq mu4e-trash-folder "/[Gmail].Trash")

       (setq mu4e-maildir-shortcuts
	     '(("/Inbox" . ?i)
	       ("/[Gmail].Sent Mail" . ?s)
	       ("/[Gmail].Trash" . ?t)
	       ("/[Gmail].Drafts" . ?d)
	       ("/[Gmail] All Mail" . ?a)))

       (setq smtpmail-smtp-server "smtp.gmail.com"
	     smtpmail-smtp-service 465
	     smtpmail-stream-type 'ssl)

       (setq message-send-mail-function 'smtpmail-send-it)

       (bind-key "C-c m" 'mu4e))
   #+END_SRC
** Dired single buffer
   #+BEGIN_SRC emacs-lisp
     (use-package dired-single
       :straight t
       :bind (("C-x C-j" . dired-jump)
	      :map dired-mode-map
	      ("RET" . dired-find-file)
	      ([backspace] . dired-single-up-directory)))
   #+END_SRC
** Evil vim bindings
#+BEGIN_SRC emacs-lisp
  (use-package evil
    :straight t
    :init
    (setq evil-want-integration t)
    (setq evil-want-keybinding nil)
    (setq evil-want-C-u-scroll t)
    (setq evil-want-C-i-jump nil)
    :config
    (evil-mode 1)
    (define-key evil-insert-state-map (kbd "C-g") 'evil-normal-state)
    (define-key evil-insert-state-map (kbd "C-h") 'evil-delete-backward-char-and-join)

    ;; Use visual line motions even outside of visual-line-mode buffers
    (evil-global-set-key 'motion "j" 'evil-next-visual-line)
    (evil-global-set-key 'motion "k" 'evil-previous-visual-line)

    (evil-set-initial-state 'messages-buffer-mode 'normal)
    (evil-set-initial-state 'dashboard-mode 'normal))

  (use-package evil-collection
    :straight t
    :after evil
    :config
    (evil-collection-init))
#+END_SRC
* Built-in packages
** Org mode
   A GNU Emacs major mode for keeping notes, authoring documents,
   computational notebooks, literate programming, maintaining to-do lists,
   planning projects, and more — in a fast and effective plain text system.

   #+BEGIN_SRC emacs-lisp
     (use-package org
       :after bind-key
       :config
       (setq org-ellipsis " ▾")

       (setq org-agenda-start-with-log-mode t)
       (setq org-log-done 'time)
       (setq org-log-into-drawer t)

       (setq org-directory (concat (getenv "HOME") "/projects/dotfiles/wiki"))
       (setq org-agenda-files '("~/projects/dotfiles/tasks/todo.org"))
       (setq org-agenda-skip-function-global '(org-agenda-skip-entry-if 'todo 'done))

	(setq org-capture-templates
	      `(("t" "Task")
		("tp" "Task Personal" entry (file+olp "~/projects/dotfiles/tasks/todo.org" "Inbox - Personal")
		 "* TODO %?\n SCHEDULED: %^t\n %a\n  %i" :empty-lines 0)
		("tw" "Task Work" entry (file+olp "~/projects/dotfiles/tasks/todo.org" "Inbox - Work")
		 "* TODO %?\n SCHEDULED: %^t\n %a\n  %i" :empty-lines 0)))

	;; Format better paragraphs
	(add-hook 'org-mode-hook 'turn-on-auto-fill)
   
	(bind-key "C-c c" 'org-capture)
	(bind-key "C-c a " 'org-agenda))
   #+END_SRC
